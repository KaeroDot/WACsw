% Search for coherent frequency and period count for a given sampling
% frequency. Tries to find solution nearest to `f_wanted` and `M_wanted`. The
% method used in the search is not iterative but use dot multiplication of
% matrices.
%
% Searched frequency is rounded to the specified number of significant digits
% according `generator_digits` (generator resolution).
%
% If search would result in too large matrices, `f_tolerance` and `M_tolerance`
% are iteratively decreased to prevent memory overload.
%
% If no solution is found within the specified tolerances, NaN values are
% returned.
%
% Inputs:
%   'fs'              : Sampling frequency in Hz, required, positive real.
%   'f_wanted'        : Desired signal frequency in Hz, required, positive real.
%   'M_wanted'        : Expected number of periods to be sampled, required, positive integer.
%   'generator_digits': Resolution of the signal generator in significant digits, positive integer.
%   'f_tolerance'     : Maximal relative change of the signal frequency to achieve coherency, Hz/Hz, real in range (0,1).
%                       (if f_tolerance is 0.1, frequency can be changed by maximally 10 % to achieve coherency)
%   'M_tolerance'     : Maximal absolute change of the number of sampled periods to achieve coherency, periods, positive integer.
%                       (if M_tolerance is 0.10, number of periods can be changed by maximally by 10 periods to achieve coherency)
%   'verbose'         : Verbose mode flag, boolean (0/1).
%
% Outputs:
%   'f_coherent'      : Nearest coherent frequency in Hz.
%   'M_coherent'      : Number of periods corresponding to the coherent frequency.
%   'N_coherent'      : Number of samples corresponding to the coherent frequency.
%   'f_coherent_u'    : Same as f_coherent, but without NaNs, duplicastes, and sorted.
%   'M_coherent_u'    : dtto
%   'N_coherent_u'    : dtto
% 
% Example 1:
% Find coherent signal frequency near 1001 Hz with about 100 periods sampled at
% 1 MHz, frequency and periods can be adjusted by maximally 10 %, signal is
% generated by a signal generator with 5 significant digits resolution:
%   [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(1e6, 1001, 100, 5, 0.1, 0.1, 1)
%
% Example 2:
% Find coherent signal frequency near 10001 Hz with about 10000 periods sampled at
% 1 GHz, frequency and periods can be adjusted by maximally 90 %, signal is
% generated by a signal generator with 9 significant digits resolution. The
% search will result in too large matrices and tolerances will be adjusted:
%   [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(1000e6, 10001, 10000, 9, 0.9, 0.9, 1)

function [f_selected, M_selected, N_selected, f_selected_u, M_selected_u, N_selected_u] = find_nearest_coherent_frequency(fs, f_wanted, M_wanted, generator_digits, f_tolerance, M_tolerance, verbose)
    %% Check inputs %<<<1
    if ~exist('fs', 'var') fs = 1e6; end
    if ~exist('f_wanted', 'var') f_wanted = []; end
    if ~exist('M_wanted', 'var') M_wanted = []; end
    if ~exist('generator_digits', 'var') generator_digits = []; end
    if ~exist('f_tolerance', 'var') f_tolerance = []; end
    if ~exist('M_tolerance', 'var') M_tolerance = []; end
    if ~exist('verbose', 'var') verbose = []; end

    if isempty(fs) fs = 1e6; end
    if isempty(f_wanted) f_wanted = 1e3; end
    if isempty(M_wanted) M_wanted = 100; end
    if isempty(generator_digits) generator_digits = 5; end
    if isempty(f_tolerance) f_tolerance = 0.10; end
    if isempty(M_tolerance) M_tolerance = 50; end
    if isempty(verbose) verbose = 0; end

    %% Validate inputs %<<<1
    % check if vectors are of same size
    % sizes
    sizes = [size(fs); size(f_wanted); size(M_wanted); size(generator_digits); size(f_tolerance); size(M_tolerance)];
    is_matrix = all(sizes > 1, 2); % rows where input is matrix
    if any(is_matrix)
        error('find_nearest_coherent_frequency: all inputs must be scalars or vectors of the same size.');
    end
    is_scalar = all(sizes == 1, 2); % rows where input is scalar
    vector_sizes = sizes(~is_scalar, :);
    if ~isempty(vector_sizes)
        % Check if all non-scalar sizes are the same
        if any(any(bsxfun(@ne, vector_sizes, vector_sizes(1,:))))
            error('find_nearest_coherent_frequency: all vector inputs must have the same size.');
        end
    end
    % Extend scalars to vectors if needed:
    if ~isempty(vector_sizes)
        % For each input, if scalar, replicate to match vector size
        target_size = vector_sizes(1,:);
        if is_scalar(1), fs = repmat(fs, target_size); end
        if is_scalar(2), f_wanted = repmat(f_wanted, target_size); end
        if is_scalar(3), M_wanted = repmat(M_wanted, target_size); end
        if is_scalar(4), generator_digits = repmat(generator_digits, target_size); end
        if is_scalar(5), f_tolerance = repmat(f_tolerance, target_size); end
        if is_scalar(6), M_tolerance = repmat(M_tolerance, target_size); end
    end

    if or(any(fs <= 0), any(f_wanted <= 0))
        error('find_nearest_coherent_frequency: frequency inputs fs and f_wanted must be greater than zero.');
    end
    if any(M_wanted < 1)
        error('find_nearest_coherent_frequency: wanted number of periods M_wanted must be at least 1.');
    end
    if any(generator_digits < 2)
        error('find_nearest_coherent_frequency: generator digits generator_digits must be at least 2 significant digits.');
    end
    if any(fix(generator_digits) ~= generator_digits)
        error('find_nearest_coherent_frequency: generator digits generator_digits must be an integer.');
    end
    if any(f_tolerance <= 0 || f_tolerance >= 1)
        error('find_nearest_coherent_frequency: frequency tolerance f_tolerance must be between 0 and 1.');
    end
    if any(fix(M_wanted) ~= M_wanted)
        error('find_nearest_coherent_frequency: wanted number of periods M_wanted must be an integer.');
    end
    verbose = logical(verbose);

    %% Loop over all elements if vector inputs %<<<1
    f_selected = NaN(size(fs));
    f_wanted_rounded = NaN(size(fs));
    M_selected = NaN(size(fs));
    N_selected = NaN(size(fs));
    for idx = 1:numel(fs)
        % Check if input already satisfies coherency and generator resolution
        if verbose
            disp(sprintf('-- Solving for: fs = %g Hz, f_wanted = %g Hz, M_wanted = %g periods, generator_digits = %d digits, f_tolerance = %g, M_tolerance = %g', ...
                fs(idx), f_wanted(idx), M_wanted(idx), generator_digits(idx), f_tolerance(idx), M_tolerance(idx)));
        end
        % round f_wanted to generator resolution (specified number of significant digits):
        f_wanted_rounded(idx) = round_to_significant_digits(f_wanted(idx), generator_digits(idx));
        if abs((f_wanted_rounded(idx) - f_wanted(idx))) > abs(2*eps(f_wanted_rounded))
            if verbose disp('   Input frequency `f_wanted` is not at generator resolution, searching for nearest coherent frequency...'); end
        else
            % f_wanted is at generator resolution, check if M_wanted is integer:
            if M_wanted(idx) ~= fix(M_wanted(idx))
                if verbose disp('Input number of periods `M_wanted` is not integer, searching for nearest coherent frequency...'); end
            else
                % M_wanted is integer, check if input is coherent:
                N(idx) = M_wanted(idx) ./ f_wanted(idx) .* fs(idx);
                if fix(N(idx)) ~= N(idx)
                    if verbose disp('   Input is not coherent, searching for nearest coherent frequency...'); end
                else
                    % input is already coherent, M is rounded, f is to
                    % generator_digits, return it directly:
                    f_selected(idx)= f_wanted(idx);
                    M_selected(idx)= M_wanted(idx);
                    N_selected(idx)= N(idx);
                    if verbose disp('   Input frequency `f_wanted` is at generator resolution, `M_wanted` is integer, and already coherent to the `fs`.'); end
                end
            end
        end

        % Search for coherent frequency
        % input is f_wanted_rounded already at generator resolution
        if isnan(f_selected(idx))
            [f_selected(idx), M_selected(idx), N_selected(idx)] = find_coherent(fs(idx), f_wanted_rounded(idx), M_wanted(idx), generator_digits(idx), f_tolerance(idx), M_tolerance(idx), verbose);
        end
    end % for idx

    %% Ensure output orientation matches input orientation using reshape %<<<1
    f_selected = reshape(f_selected, size(fs));
    M_selected = reshape(M_selected, size(fs));
    N_selected = reshape(N_selected, size(fs));

    % remove NaNs from outputs:
    idx = isnan(f_selected);
    f_selected_u = f_selected(not(idx));
    M_selected_u = M_selected(not(idx));
    N_selected_u = N_selected(not(idx));
    % remove duplicates from outputs:
    [f_selected_u, idx] = unique(f_selected_u);
    M_selected_u = M_selected_u(idx);
    N_selected_u = N_selected_u(idx);

end % function find_nearest_coherent_frequency

%% find coherent frequency function %<<<1
function [f_selected, M_selected, N_selected] = find_coherent(fs, f_wanted, M_wanted, generator_digits, f_tolerance, M_tolerance, verbose)
    % Function to find a coherent frequency and corresponding number of periods
    % that satisfy the sampling constraints for a given sampling frequency and
    % desired signal frequency. If search would result in too large matrices,
    % f_tolerance and M_tolerance are iteratively decreased.
    %
    % Inputs:
    %   'fs': sampling frequency, Hz, required, positive real.
    %   'f_wanted': desired signal frequency, Hz, required, positive real, rounded to generator resolution.
    %   'M_wanted': expected number of periods to be sampled, periods, required, positive integer.
    %   'generator_digits': resolution of the signal generator in significant digits, positive integer.
    %   'f_tolerance': maximal relative change of the signal frequency to achieve coherency, Hz/Hz, real in range (0,1).
    %   'M_tolerance': maximal absolute change of the number of sampled periods to achieve coherency, periods, positive integer.
    %   'verbose': verbose mode flag, boolean (0/1).

    M_step = 1; % Step size for period adjustments
    max_matrix_elements = 1e6; % Maximum allowed size of the search grid

    tolerances_were_decreased = false;
    while true
        % Determine the range of candidate periods
        M_boundary = M_wanted * M_tolerance;
        M_min = M_wanted - M_boundary;
        M_min = max(1, round(M_min)); % Ensure number of minimum periods is at least one
        M_max = M_wanted + M_boundary;
        M_max = max(2, round(M_max)); % Ensure number of maximum periods is at least two
        % construct candidate periods
        M_candidate = M_min:M_step:M_max;
        if verbose disp(sprintf('   Searching in range of periods from %d to %d, %d elements ...', M_candidate(1), M_candidate(end), numel(M_candidate) )); end
        if numel(M_candidate) < 2
            error('find_nearest_coherent_frequency: cannot create list of periods to be searched, M_tolerance is too small.');
        end

        % Determine the frequency step size
        mag_f_wanted = 10^floor(log10(f_wanted)); % Magnitude order of the required frequency
        f_step = mag_f_wanted / 10^(generator_digits - 1); % Frequency step size
        % Define the range of candidate frequencies
        f_boundary = f_wanted * f_tolerance;
        f_min = f_wanted - f_boundary;
        f_min = max(eps(f_wanted), f_min); % Ensure frequency is at least eps
        f_max = f_wanted + f_boundary;
        f_max = max(10*eps, f_max); % Ensure frequency is at least 10*eps
        % construct candidates by stepping up from f_wanted, and stepping down from f_wanted:
        f_candidate = [ fliplr(f_wanted - f_step : -1.*f_step : f_min) f_wanted : f_step : f_max];
        if verbose disp(sprintf('   Searching in range of frequencies from %g to %g, %d elements ...', f_candidate(1), f_candidate(end), numel(f_candidate) )); end
        if numel(f_candidate) < 2
            error('find_nearest_coherent_frequency: cannot create list of frequencies to be searched, f_tolerance is too small or generator_digits is too low.');
        end

        % check size of the grid to be constructed:
        grid_size = numel(f_candidate) * numel(M_candidate);
        if verbose disp(sprintf('      The grid of candidate frequencies and periods would have %g elements ...', grid_size )); end
        if grid_size < max_matrix_elements
            % grid size is acceptable, exit the loop
            break
        else
            % if grid is too large, decreasing matrix to 1/4.
            if numel(f_candidate) > numel(M_candidate)
                % decrease frequency tolerance
                f_tolerance = f_tolerance / 2;
            else
                % decrease M tolerance
                M_tolerance = M_tolerance / 2;
            end
            tolerances_were_decreased = true;
            if verbose disp(sprintf('      Searching for coherent frequency would result in matrices with %g elements, that is too large, decreasing f_tolerance to %g and M_tolerance to %g...', grid_size, f_tolerance, M_tolerance)); end
        end
    end % while

    % Create a grid of candidate frequencies and periods
    [f_grid, M_grid] = meshgrid(f_candidate, M_candidate);

    % Calculate coherency of the grid:
    % number of samples:
    % N = M/f*fs
    N = M_grid ./ f_grid .* fs;
    coherent = fix(N) == N; % Logical matrix indicating coherent combinations
    % If any coherent combination is found, select the one in the middle of the grid
    if any(any(coherent))
        if verbose disp(sprintf('   Found %d coherent frequency/period combinations, selecting the nearest to the wanted one...', sum(sum(coherent)) ) ); end
        % Find the row and column indices of the nearest coherent point
        [idr, idc] = findOneNearestToCenter(coherent);
        % Extract the corresponding frequency and period
        f_selected = f_grid(idr, idc);
        M_selected = M_grid(idr, idc);
        N_selected = M_selected / f_selected * fs;
    else
        % Error if no coherent frequency is found
        if tolerances_were_decreased
            tol_str = 'Increasing tolerances will NOT help due to memory constrains.';
        else
            tol_str = 'Increasing tolerances MIGHT help.';
        end
        warning('find_nearest_coherent_frequency: cannot find coherent frequency for fs = %g, f_wanted = %g, M_wanted = %g, generator_digits = %d, f_tolerance = %g, M_tolerance = %g. %s', ...
            fs, f_wanted, M_wanted, generator_digits, f_tolerance, M_tolerance, tol_str);
        f_selected = NaN;
        M_selected = NaN;
        N_selected = NaN;
    end % any(any(coherent))
end

%% round to significant digits %<<<1
function rounded_value = round_to_significant_digits(value, significant_digits)
    % Rounds a given value to the specified number of significant digits.
    % Inputs:
    %   value: The value to be rounded (scalar or array)
    %   significant_digits: The number of significant digits to round to (positive integer)

    if significant_digits < 1 || fix(significant_digits) ~= significant_digits
        error('find_nearest_coherent_frequency: significant_digits must be a positive integer.');
    end

    % Calculate the magnitude of the value
    magnitude = 10 .^ floor(log10(abs(value)));

    % Round the value to the specified number of significant digits
    rounded_value = round(value ./ magnitude .* 10^(significant_digits - 1)) ./ 10^(significant_digits - 1) .* magnitude;
end

%% find one nearest to the center of the matrix %<<<1
function [nearest_row, nearest_col] = findOneNearestToCenter(matrix)
    % Helper function to find the location of the element with value 1
    % that is nearest to the center of a given matrix.
    % Used to find coherent frequency/period combination that is nearest to
    % the expected one.
    % Inputs:
    %   matrix: Input logical matrix (zeros and ones)

    % Get the dimensions of the matrix
    [mat_rows, mat_cols] = size(matrix);

    % Compute the center of the matrix
    center_row = round(mat_rows / 2);
    center_row = max(1, center_row); % Ensure at least 1
    center_col = round(mat_cols / 2);
    center_col = max(1, center_col); % Ensure at least 1

    % Find the positions of all ones in the matrix
    [one_rows, one_cols] = find(matrix == 1);

    % Calculate the Euclidean distance of each one to the center
    distances = sqrt((one_rows - center_row).^2 + (one_cols - center_col).^2);

    % Find the index of the minimum distance
    [~, idx] = min(distances);

    % Return the row and column indices of the nearest one
    nearest_row = one_rows(idx);
    nearest_col = one_cols(idx);
end

%Demonstration: Find a coherent frequency near 1001 Hz, 100 periods, 1 MHz sampling, 5 digits, 10 % tolerance
%!demo
%! fs = 1e6;
%! f_wanted = 1001;
%! M_wanted = 100;
%! generator_digits = 5;
%! f_tolerance = 0.1;
%! M_tolerance = 0.1;
%! verbose = 1;
%! [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(fs, f_wanted, M_wanted, generator_digits, f_tolerance, M_tolerance, verbose);
%! disp(['Selected frequency: ', num2str(f_selected), ' Hz']);
%! disp(['Selected periods: ', num2str(M_selected)]);
%! disp(['Selected samples: ', num2str(N_selected)]);

%!test
%! % Basic test: 1 MHz sampling, 1001 Hz wanted, 100 periods, 5 digits, 10% tolerance
%! [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(1e6, 1001, 100, 5, 0.1, 0.1, 0);
%! assert(f_selected, 1000, eps(f_selected))
%! assert(M_selected, 100, eps(M_selected))
%! assert(N_selected, 100e3, eps(N_selected))

%!test
%! % Already coherent input: 1 kHz, 100 periods, 1 MHz, 5 digits
%! [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(1e6, 1e3, 100, 5, 0.1, 0.1, 0);
%! assert(f_selected, 1e3, eps(f_selected))
%! assert(M_selected, 100, eps(M_selected));
%! assert(N_selected, 1e5, eps(N_selected));

%!test
%! % Large search: 1 GHz, 10001 Hz, 10000 periods, 9 digits, 90% tolerance
%! [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(1e9, 10001, 10000, 9, 0.9, 0.9, 0);
%! assert(abs(f_selected - 10001) < 9000.9); % within 90%
%! assert(abs(M_selected - 10000) <= 9000);  % within 90%
%! assert(abs(N_selected - round(N_selected)) < 1e-10);

%!test
%! % Check error on invalid fs
%! fail('find_nearest_coherent_frequency(0, 1000, 100, 5, 0.1, 0.1, 0)', 'frequency inputs fs and f_wanted must be greater than zero');

%!test
%! % Check error on invalid M_wanted
%! fail('find_nearest_coherent_frequency(1e6, 1000, 0, 5, 0.1, 0.1, 0)', 'wanted number of periods M_wanted must be at least 1');

%!test
%! % All inputs (but verbose) are vectors of same size
%! n = 5;
%! fs = ones(1,n)*1e6;
%! f_wanted = linspace(1000, 1020, n);
%! M_wanted = 100*ones(1,n);
%! generator_digits = 5*ones(1,n);
%! f_tolerance = 0.1*ones(1,n);
%! M_tolerance = 0.1*ones(1,n);
%! verbose = 0;
%! [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(fs, f_wanted, M_wanted, generator_digits, f_tolerance, M_tolerance, verbose);
%! assert(all(size(f_selected) == [1 n]));
%! assert(all(size(M_selected) == [1 n]));
%! assert(all(size(N_selected) == [1 n]));

%!test
%! % Only some inputs are vectors, others are scalars
%! n = 4;
%! fs = 1e6;
%! f_wanted = linspace(1000, 1100, n);
%! M_wanted = 100;
%! generator_digits = 5;
%! f_tolerance = 0.3;
%! M_tolerance = 0.3*ones(1,n);
%! verbose = 0;
%! [f_selected, M_selected, N_selected] = find_nearest_coherent_frequency(fs, f_wanted, M_wanted, generator_digits, f_tolerance, M_tolerance, verbose);
%! assert(all(size(f_selected) == [1 n]));
%! assert(all(size(M_selected) == [1 n]));
%! assert(all(size(N_selected) == [1 n]));

%!test
%! % No coherent frequency can be found with extremely tight tolerances
%! fail('find_nearest_coherent_frequency(1e6, 1001, 100, 5, 1e-10, 1e-10, 0)');

% vim settings modeline: vim: foldmarker=%<<<,%>>> fdm=marker fen ft=matlab textwidth=80 tabstop=4 shiftwidth=4
