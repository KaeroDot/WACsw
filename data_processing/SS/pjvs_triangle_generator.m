% Simulates triangle step waveform generated by PJVS. It can generate only
% coherent triangle, nothing else.
% Any input quantity can be set to empty value []. Default value will be set for
% this quantity. Either specify 't' and keep 'L' and 'fs' empty or keep 't'
% empty and specify 'L' and 'fs'. If both 't' and 'L','fs' will be specified,
% 't' got preference.
%
% Inputs:
% fs - frequency of the samples (sampling frequency) (Hz), scalar.
% L - number of samples (record length), scalar.
% t - ignored
% f - frequency of the reference waveform (Hz), scalar.
% A - amplitude of the reference waveform (V), scalar.
% ph - ignored
% fstep - frequency of the PJVS steps (Hz), scalar.
% phstep - ignored
% fm - microwave frequency (Hz), scalar.
% waveformtype - ignored
% verbose = verbosity level
%
% Outputs:
% y - samples of the quantized reference waveform (V).
% n - quantum numbers in every PJVS step (int).
% Upjvs - PJVS voltages of all PJVS steps (V).
% Upjvs1period - PJVS voltages of PJVS steps in one period of reference waveform (V).
% Spjvs - indexes of samples of PJVS switches - switch happen before or at the sample.
% tsamples - times of samples of y (s).
%
% Example:
% [y, n, Upjvs, Upjvs1period, Spjvs, tsamples] = pjvs_triangle_generator();
% plot(t, y);

function [y, n, Upjvs, Upjvs1period, Spjvs, tsamples] = pjvs_triangle_generator(fs, L, t, f, A, ph, fstep, phstep, fm, waveformtype, verbose)
    % Constants %<<<1

    % Josephson constant, 2e/h:
    h = 6.62607015e-34;
    e = 1.602176634e-19;
    KJ = 2*e/h; % (Hz/V)

    % treat user inputs %<<<1
    % set default values
    if ~exist('fs', 'var') fs = []; end
    if ~exist('L', 'var') L = []; end
    if ~exist('t', 'var') t = []; end
    if ~exist('f', 'var') f = []; end
    if ~exist('A', 'var') A = []; end
    if ~exist('ph', 'var') ph = []; end
    if ~exist('fstep', 'var') fstep = []; end
    if ~exist('phstep', 'var') phstep = []; end
    if ~exist('fm', 'var') fm = []; end
    if ~exist('waveformtype', 'var') waveformtype = []; end
    if ~exist('verbose', 'var') verbose = 1; end
    if isempty(t)
        % time series was not provided
        if isempty(fs) fs = 200; end
        if isempty(L) L = 200; end
    else
        L = [];
        fs = [];
    end
    if isempty(f) f = 1; end
    if isempty(A) A = 1; end
    if isempty(ph) ph = 0; end
    if isempty(fstep) fstep = 40; end
    if isempty(phstep) phstep = 0; end
    if isempty(fm) fm = 75e9; end
    if isempty(waveformtype) waveformtype = 2; end
    if isempty(verbose) verbose = 1; end

    if isempty(t)
        if L <= 0
            error('pjvs_wvfrm_generator: Number of samples `L` must be greater than zero!')
        end
        if fs <= 0
            error('pjvs_wvfrm_generator: Frequency of the samples `fs` must be greater than zero!')
        end
    else
        if numel(t) == 0
            error('pjvs_wvfrm_generator: Time of samples `t` must contain at least one value!')
        end
    end % if isempty(t)
    if any([fs f fstep fm] <= 0)
        error('pjvs_wvfrm_generator: All frequencies (`fs`, `f`, `fstep`, `fm`) must be greater than zero!')
    end
    if A <= 0
        error('pjvs_wvfrm_generator: Amplitude `A` must be greater than zero!')
    end
    verbose = not(not(verbose));

    % initialize values %<<<1
    % minimum voltage step for actual microwave frequency:
    VS = fm/KJ;

    % Generate purely coherent triangle with samples %<<<1
    % number of triangles in the whole record:
    trianglesinrecord = L./fs.*f;
    if not(fix(trianglesinrecord) == trianglesinrecord)
        error(sprintf('pjvs_triangle_generator: number of triangle periods in the whole record is %g <- must be integer number!', trianglesinrecord))
    end
    % samples in one PJVS step:
    samplesperstep = fs./fstep;
    if not(fix(samplesperstep) == samplesperstep)
        error(sprintf('pjvs_triangle_generator: number of samples in one PJVS step is %g <- must be integer number!', samplesperstep))
    end
    % steps in triangle:
    stepsno = fstep./f;
    if not(fix(stepsno) == stepsno)
        error(sprintf('pjvs_triangle_generator: number steps in the triangle is %g <- must be integer number!', stepsno))
    end
    if not(fix(stepsno./4) == stepsno./4)
        error('pjvs_triangle_generator: number steps in the triangle must be divisible by 4!')
    end

    % minimum difference of two PJVS steps to cover the whole amplitude:
    min_U = 2*A./(stepsno./2);
    % how big change of quantized voltage must be to cover min_U:
    delta_U = ceil(min_U./VS).*VS;
    % triangular voltage series for one triangle period:
    Upjvs1period = [-stepsno/4 : stepsno/4].*delta_U;
    Upjvs1period = [Upjvs1period Upjvs1period(end-1 : -1 : 2)];
    Upjvs1period = circshift(Upjvs1period, -stepsno/4);
    % triangles for whole record:
    Upjvs = repmat(Upjvs1period, trianglesinrecord);

    % quantum numbers:
    n = Upjvs.*KJ;

    % generate actual samples:
    y = repmat(Upjvs(:), 1, samplesperstep);
    y = reshape(y', 1, []);

    % time of samples:
    tsamples = [0 : 1 : L-1]./fs;

    % indexes of step change:
    Spjvs = [1 : samplesperstep : L];
    % Ensure Spjvs proper values
    % ensure start and ends of record as PJVS segments
    Spjvs(Spjvs < 1) = [];
    Spjvs(Spjvs > numel(y) + 1) = [];
    if Spjvs(1) ~= 1
        Spjvs = [1 Spjvs];
    end
    if Spjvs(end) ~= numel(y) + 1
        % because Spjvs marks start of step, next
        % step is after the last data sample
        Spjvs(end+1) = numel(y) + 1;
    end

    % DEBUG - part only for debugging or detailed inspection %<<<1
    if verbose
        % print out some information
        if isempty(t)
            no = L;
        else
            no = numel(t);
        end
        disp('---')
        disp('pjvs_triangle_generator DEBUG informations:')
        printf('Change of quantum number by 1 is equal to: %.4g V\n', VS);
        % To move phase of steps by half sample: that is ratio of 0.5*sampling
        % period to step period times 2*pi.
        printf('Number of samples in PJVS step: %d\n', samplesperstep)
        printf('No. of PJVS steps: %d\n', numel(Upjvs));
        printf('No. of used PJVS steps in one period of triangle waveform: %d\n', numel(Upjvs1period));

        % overview plot
        figure()
        hold on
        plot(tsamples, y, 'x-b')
        plot(tsamples(Spjvs(1:end-1)), y(Spjvs(1:end-1)), 'ok', 'markersize', 6, 'linewidth', 2)
        ylims = ylim;
        % plot times of step change
        tstepchange = tsamples(Spjvs(1:end-1));
        for j = 1:numel(tstepchange)
            plot([tstepchange(j) tstepchange(j)], ylims, ':k')
        end
        legend('PJVS at samples', 'Step switch at samples', 'time of a step change')
        hold off
        xlabel('t (s)')
        ylabel('voltage (V)')
        title(sprintf('pjvs_triangle_generator.m'), 'interpreter', 'none')
    end % if DEBUG

end % function

% tests  %<<<1
% TODO NOT OK! OLD! FIX! XXX
% TODO more tests should be present
%!test
%!shared fs, L, t, f, A, ph, fstep, phstep, fm, waveformtype, y, n, Upjvs, Upjvs1period, Spjvs, tsamples
%! fs = 1000;
%! L = 1000;
%! t = [];
%! f = 1;
%! A = 1;
%! ph = 0*pi;
%! fstep = 10;
%! phstep = 0;
%! fm = 75e9;
%! waveformtype = 1;
%! [y, n, Upjvs, Upjvs1period, Spjvs, tsamples] = pjvs_wvfrm_generator2(fs, L, t, f, A, ph, fstep, phstep, fm, waveformtype);
%!assert(size(y, 2) == L);
%!assert(size(n, 2) == 10);
%!assert(size(Upjvs, 2) == 10);
%!assert(size(Upjvs1period, 2) == 10);
%!assert(size(Spjvs, 2) == 10);
%!assert(size(tsamples, 2) == L);
%!assert(all(n == [1960 5131 6342 5131 1960 -1960 -5131 -6342 -5131 -1960]))
%! A=2;
%! [y, n, Upjvs, Upjvs1period, Spjvs, tsamples] = pjvs_wvfrm_generator2(fs, L, t, f, A, ph, fstep, phstep, fm, waveformtype);
%!assert(n(1) == 2*1960)
%! phstep = pi;
%! [y, n, Upjvs, Upjvs1period, Spjvs, tsamples] = pjvs_wvfrm_generator2(fs, L, t, f, A, ph, fstep, phstep, fm, waveformtype);
%!assert(size(n, 2) == 11);

% demo %<<<1
% TODO NOT OK! OLD! FIX! XXX
% terrible inputs and nice figure:
%!demo
%! fs = 100;
%! L = 200;
%! f = 1;
%! A = 1;
%! ph = 0;
%! fstep = 10;
%! phstep = 0;
%! fm = 75e9;
%! waveformtype = 1;
%! [y, n, Upjvs, Upjvs1period, Spjvs, tsamples] = pjvs_wvfrm_generator2(fs, L, [], f, A, ph, fstep, phstep, fm, waveformtype);
%! plot(tsamples, y, '-x')
%! xlabel('t (s)')
%! ylabel('sampled PJVS voltage (V)')
%! title('PJVS steps')

% vim settings modeline: vim: foldmarker=%<<<,%>>> fdm=marker fen ft=matlab textwidth=80 tabstop=4 shiftwidth=4
